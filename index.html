<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixel Art Editor</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background-color: #f0f0f0;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .editor-container {
            display: flex;
            gap: 30px;
            margin-bottom: 20px;
        }
        
        .canvas-section {
            flex: 1;
        }
        
        .preview-section {
            width: 300px;
            background-color: #f8f8f8;
            padding: 20px;
            border-radius: 8px;
        }
        
        .preview-section h3 {
            margin-top: 0;
            margin-bottom: 15px;
            font-size: 16px;
            color: #333;
        }
        
        .preview-box {
            background-image: 
                linear-gradient(45deg, #ddd 25%, transparent 25%), 
                linear-gradient(-45deg, #ddd 25%, transparent 25%), 
                linear-gradient(45deg, transparent 75%, #ddd 75%), 
                linear-gradient(-45deg, transparent 75%, #ddd 75%);
            background-size: 10px 10px;
            background-position: 0 0, 0 5px, 5px -5px, -5px 0px;
            border: 1px solid #ccc;
            padding: 20px;
            text-align: center;
            margin-bottom: 20px;
            min-height: 100px;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }
        
        #previewCanvas {
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }
        
        .scale-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .scale-button {
            padding: 5px 10px;
            border: 1px solid #ccc;
            background-color: white;
            cursor: pointer;
            border-radius: 4px;
            font-size: 12px;
        }
        
        .scale-button:hover {
            background-color: #f0f0f0;
        }
        
        .scale-button.active {
            background-color: #4CAF50;
            color: white;
            border-color: #4CAF50;
        }
        
        h1 {
            text-align: center;
            color: #333;
        }
        
        .controls {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            align-items: center;
        }
        
        .color-picker {
            display: flex;
            gap: 5px;
            align-items: center;
        }
        
        .color-button {
            width: 30px;
            height: 30px;
            border: 2px solid #ccc;
            cursor: pointer;
            transition: transform 0.1s;
        }
        
        .color-button:hover {
            transform: scale(1.1);
        }
        
        .color-button.selected {
            border: 3px solid #333;
        }
        
        #customColor {
            width: 50px;
            height: 30px;
            cursor: pointer;
        }
        
        .tool-button {
            padding: 8px 15px;
            border: 1px solid #ccc;
            background-color: white;
            cursor: pointer;
            border-radius: 4px;
            transition: background-color 0.2s;
        }
        
        .tool-button:hover {
            background-color: #f0f0f0;
        }
        
        .tool-button.active {
            background-color: #4CAF50;
            color: white;
        }
        
        #canvas-container {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
        }
        
        #pixelCanvas {
            border: 2px solid #333;
            cursor: crosshair;
            background-image: 
                linear-gradient(45deg, #ddd 25%, transparent 25%), 
                linear-gradient(-45deg, #ddd 25%, transparent 25%), 
                linear-gradient(45deg, transparent 75%, #ddd 75%), 
                linear-gradient(-45deg, transparent 75%, #ddd 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
        }
        
        .action-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
        }
        
        button {
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.2s;
        }
        
        .btn-primary {
            background-color: #4CAF50;
            color: white;
        }
        
        .btn-primary:hover {
            background-color: #45a049;
        }
        
        .btn-secondary {
            background-color: #f44336;
            color: white;
        }
        
        .btn-secondary:hover {
            background-color: #da190b;
        }
        
        .btn-info {
            background-color: #2196F3;
            color: white;
        }
        
        .btn-info:hover {
            background-color: #0b7dda;
        }
        
        .grid-size {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        input[type="number"] {
            width: 60px;
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        
        .shift-controls {
            display: flex;
            gap: 5px;
            align-items: center;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Pixel Art Editor</h1>
        
        <div class="controls">
            <div class="color-picker">
                <span>Color:</span>
                <div class="color-button selected" data-color="#000000" style="background-color: #000000"></div>
                <div class="color-button" data-color="#FF0000" style="background-color: #FF0000"></div>
                <div class="color-button" data-color="#00FF00" style="background-color: #00FF00"></div>
                <div class="color-button" data-color="#0000FF" style="background-color: #0000FF"></div>
                <div class="color-button" data-color="#FFFF00" style="background-color: #FFFF00"></div>
                <div class="color-button" data-color="#FF00FF" style="background-color: #FF00FF"></div>
                <div class="color-button" data-color="#00FFFF" style="background-color: #00FFFF"></div>
                <div class="color-button" data-color="#FFFFFF" style="background-color: #FFFFFF"></div>
                <div class="color-button" data-color="transparent" style="background-image: linear-gradient(45deg, #ccc 25%, transparent 25%), linear-gradient(-45deg, #ccc 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #ccc 75%), linear-gradient(-45deg, transparent 75%, #ccc 75%); background-size: 10px 10px; background-position: 0 0, 0 5px, 5px -5px, -5px 0px;"></div>
                <input type="color" id="customColor" value="#000000">
            </div>
            
            <div class="tools">
                <button class="tool-button active" data-tool="draw">Draw</button>
                <button class="tool-button" data-tool="erase">Erase</button>
                <button class="tool-button" data-tool="fill">Fill</button>
            </div>
            
            <div class="grid-size">
                <span>Grid:</span>
                <input type="number" id="gridWidth" value="16" min="8" max="64">
                <span>×</span>
                <input type="number" id="gridHeight" value="16" min="8" max="64">
                <button class="btn-info" onclick="updateGridSize()">Update</button>
            </div>
            
            <div class="shift-controls">
                <button class="tool-button" onclick="shiftPixels('up')" title="Shift Up">↑</button>
                <button class="tool-button" onclick="shiftPixels('down')" title="Shift Down">↓</button>
                <button class="tool-button" onclick="shiftPixels('left')" title="Shift Left">←</button>
                <button class="tool-button" onclick="shiftPixels('right')" title="Shift Right">→</button>
            </div>
        </div>
        
        <div class="editor-container">
            <div class="canvas-section">
                <div id="canvas-container">
                    <svg id="pixelCanvas" width="512" height="512" xmlns="http://www.w3.org/2000/svg">
                    </svg>
                </div>
            </div>
            
            <div class="preview-section">
                <h3>Real-time Preview</h3>
                <div class="scale-controls">
                    <span>Scale:</span>
                    <button class="scale-button active" data-scale="1">1x</button>
                    <button class="scale-button" data-scale="2">2x</button>
                    <button class="scale-button" data-scale="4">4x</button>
                    <button class="scale-button" data-scale="8">8x</button>
                    <button class="scale-button" data-scale="16">16x</button>
                </div>
                <div class="preview-box">
                    <svg id="previewCanvas" xmlns="http://www.w3.org/2000/svg"></svg>
                </div>
                <div style="text-align: center; color: #666; font-size: 12px;">
                    <span id="previewSize"></span>
                </div>
                <div style="margin-top: 15px;">
                    <input type="file" id="bgUpload" accept="image/*" style="display: none;" onchange="handleBackgroundUpload(event)">
                    <button class="tool-button" onclick="document.getElementById('bgUpload').click()" style="width: 100%;">Upload Background</button>
                    <button class="tool-button" onclick="clearBackground()" style="width: 100%; margin-top: 5px;">Clear Background</button>
                </div>
            </div>
        </div>
        
        <div class="action-buttons">
            <button class="btn-info" onclick="undo()" title="Undo (Cmd+Z)">↶ Undo</button>
            <button class="btn-info" onclick="redo()" title="Redo (Cmd+Shift+Z)">↷ Redo</button>
            <input type="file" id="fileUpload" accept=".svg" style="display: none;" onchange="handleFileUpload(event)">
            <button class="btn-info" onclick="document.getElementById('fileUpload').click()">Upload SVG</button>
            <button class="btn-primary" onclick="downloadImage()">Download PNG</button>
            <button class="btn-primary" onclick="downloadSVG()">Download SVG</button>
            <button class="btn-secondary" onclick="if(confirm('Clear the entire canvas?')) clearCanvas()">Clear</button>
        </div>
    </div>

    <script>
        let currentColor = '#000000';
        let currentTool = 'draw';
        let isDrawing = false;
        let gridWidth = 16;
        let gridHeight = 16;
        let pixelSize = 32;
        let pixels = [];
        let history = [];
        let historyStep = -1;
        const maxHistorySize = 50;
        let previewScale = 1;
        let isColorPickerMode = false;
        let isTransparentMode = false;
        let backgroundImage = null;
        
        const canvas = document.getElementById('pixelCanvas');
        const previewCanvas = document.getElementById('previewCanvas');
        const previewSize = document.getElementById('previewSize');
        
        // History management
        function saveState() {
            const state = [];
            for (let y = 0; y < gridHeight; y++) {
                state[y] = [];
                for (let x = 0; x < gridWidth; x++) {
                    state[y][x] = pixels[y][x].getAttribute('fill');
                }
            }
            
            // Remove any states after current step
            history = history.slice(0, historyStep + 1);
            
            // Add new state
            history.push({
                state: state,
                width: gridWidth,
                height: gridHeight
            });
            
            // Limit history size
            if (history.length > maxHistorySize) {
                history.shift();
            } else {
                historyStep++;
            }
        }
        
        function undo() {
            if (historyStep > 0) {
                historyStep--;
                restoreState(history[historyStep]);
            }
        }
        
        function redo() {
            if (historyStep < history.length - 1) {
                historyStep++;
                restoreState(history[historyStep]);
            }
        }
        
        function restoreState(historyItem) {
            const { state, width, height } = historyItem;
            
            // Update grid size if needed
            if (width !== gridWidth || height !== gridHeight) {
                gridWidth = width;
                gridHeight = height;
                document.getElementById('gridWidth').value = width;
                document.getElementById('gridHeight').value = height;
                pixelSize = Math.min(512 / gridWidth, 512 / gridHeight);
                initializeGrid(false);
            }
            
            // Restore pixel colors
            for (let y = 0; y < gridHeight; y++) {
                for (let x = 0; x < gridWidth; x++) {
                    if (state[y] && state[y][x]) {
                        pixels[y][x].setAttribute('fill', state[y][x]);
                    }
                }
            }
            updatePreview();
        }
        
        // Initialize grid
        function initializeGrid(saveHistory = true) {
            canvas.innerHTML = '';
            pixels = [];
            
            const canvasWidth = gridWidth * pixelSize;
            const canvasHeight = gridHeight * pixelSize;
            
            canvas.setAttribute('width', canvasWidth);
            canvas.setAttribute('height', canvasHeight);
            
            // Don't create a background rect - let CSS handle the checkerboard pattern
            
            // Create grid
            for (let y = 0; y < gridHeight; y++) {
                pixels[y] = [];
                for (let x = 0; x < gridWidth; x++) {
                    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    rect.setAttribute('x', x * pixelSize);
                    rect.setAttribute('y', y * pixelSize);
                    rect.setAttribute('width', pixelSize);
                    rect.setAttribute('height', pixelSize);
                    rect.setAttribute('fill', 'transparent');
                    rect.setAttribute('stroke', '#ddd');
                    rect.setAttribute('stroke-width', '1');
                    rect.dataset.x = x;
                    rect.dataset.y = y;
                    
                    canvas.appendChild(rect);
                    pixels[y][x] = rect;
                }
            }
            
            // Save initial state
            if (saveHistory) {
                saveState();
            }
            
            // Update preview
            updatePreview();
        }
        
        // Preview functions
        function updatePreview() {
            const actualWidth = gridWidth;
            const actualHeight = gridHeight;
            const scaledWidth = actualWidth * previewScale;
            const scaledHeight = actualHeight * previewScale;
            
            // Set style dimensions to maintain aspect ratio
            previewCanvas.style.width = scaledWidth + 'px';
            previewCanvas.style.height = scaledHeight + 'px';
            
            // Set the actual SVG dimensions to match the grid
            previewCanvas.setAttribute('width', actualWidth);
            previewCanvas.setAttribute('height', actualHeight);
            previewCanvas.setAttribute('viewBox', `0 0 ${actualWidth} ${actualHeight}`);
            
            // Clear preview
            previewCanvas.innerHTML = '';
            
            // Add background image if exists
            if (backgroundImage) {
                const image = document.createElementNS('http://www.w3.org/2000/svg', 'image');
                image.setAttribute('href', backgroundImage);
                image.setAttribute('x', '0');
                image.setAttribute('y', '0');
                image.setAttribute('width', actualWidth);
                image.setAttribute('height', actualHeight);
                image.setAttribute('preserveAspectRatio', 'xMidYMid slice');
                previewCanvas.appendChild(image);
            }
            
            // Copy pixels to preview
            for (let y = 0; y < gridHeight; y++) {
                for (let x = 0; x < gridWidth; x++) {
                    const color = pixels[y][x].getAttribute('fill');
                    if (color !== 'transparent') {
                        const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        rect.setAttribute('x', x);
                        rect.setAttribute('y', y);
                        rect.setAttribute('width', 1);
                        rect.setAttribute('height', 1);
                        rect.setAttribute('fill', color);
                        previewCanvas.appendChild(rect);
                    }
                }
            }
            
            // Update size display
            previewSize.textContent = `${actualWidth} × ${actualHeight} pixels`;
        }
        
        // Color selection
        document.querySelectorAll('.color-button').forEach(button => {
            button.addEventListener('click', function() {
                document.querySelectorAll('.color-button').forEach(b => b.classList.remove('selected'));
                this.classList.add('selected');
                currentColor = this.dataset.color;
                document.getElementById('customColor').value = currentColor;
            });
        });
        
        document.getElementById('customColor').addEventListener('change', function() {
            currentColor = this.value;
            document.querySelectorAll('.color-button').forEach(b => b.classList.remove('selected'));
        });
        
        // Tool selection
        document.querySelectorAll('.tool-button').forEach(button => {
            button.addEventListener('click', function() {
                document.querySelectorAll('.tool-button').forEach(b => b.classList.remove('active'));
                this.classList.add('active');
                currentTool = this.dataset.tool;
            });
        });
        
        // Drawing functions
        function drawPixel(x, y) {
            if (x >= 0 && x < gridWidth && y >= 0 && y < gridHeight) {
                if (currentTool === 'draw') {
                    pixels[y][x].setAttribute('fill', currentColor);
                } else if (currentTool === 'erase') {
                    pixels[y][x].setAttribute('fill', 'transparent');
                }
                updatePreview();
            }
        }
        
        function floodFill(startX, startY, targetColor, fillColor) {
            if (targetColor === fillColor) return;
            
            const stack = [[startX, startY]];
            const visited = new Set();
            
            while (stack.length > 0) {
                const [x, y] = stack.pop();
                const key = `${x},${y}`;
                
                if (visited.has(key) || x < 0 || x >= gridWidth || y < 0 || y >= gridHeight) {
                    continue;
                }
                
                visited.add(key);
                
                if (pixels[y][x].getAttribute('fill') === targetColor) {
                    pixels[y][x].setAttribute('fill', fillColor);
                    
                    stack.push([x + 1, y]);
                    stack.push([x - 1, y]);
                    stack.push([x, y + 1]);
                    stack.push([x, y - 1]);
                }
            }
            updatePreview();
        }
        
        // Mouse events
        canvas.addEventListener('mousedown', function(e) {
            isDrawing = true;
            if (currentTool !== 'fill') {
                saveState();
            }
            handleMouseAction(e);
        });
        
        canvas.addEventListener('mousemove', function(e) {
            if (isDrawing && currentTool !== 'fill') {
                handleMouseAction(e);
            }
        });
        
        canvas.addEventListener('mouseup', function() {
            isDrawing = false;
        });
        
        canvas.addEventListener('mouseleave', function() {
            isDrawing = false;
        });
        
        function handleMouseAction(e) {
            const rect = canvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) / pixelSize);
            const y = Math.floor((e.clientY - rect.top) / pixelSize);
            
            if (x < 0 || x >= gridWidth || y < 0 || y >= gridHeight) return;
            
            // Color picker mode (C key pressed)
            if (isColorPickerMode) {
                const pickedColor = pixels[y][x].getAttribute('fill');
                if (pickedColor !== 'transparent') {
                    currentColor = pickedColor;
                    document.getElementById('customColor').value = pickedColor;
                    // Update color button selection
                    document.querySelectorAll('.color-button').forEach(b => {
                        if (b.dataset.color === pickedColor) {
                            document.querySelectorAll('.color-button').forEach(btn => btn.classList.remove('selected'));
                            b.classList.add('selected');
                        } else {
                            b.classList.remove('selected');
                        }
                    });
                }
                return;
            }
            
            // Transparent mode (X key pressed)
            if (isTransparentMode) {
                if (!isDrawing) {
                    saveState();
                }
                pixels[y][x].setAttribute('fill', 'transparent');
                updatePreview();
                return;
            }
            
            if (currentTool === 'fill') {
                const targetColor = pixels[y][x].getAttribute('fill');
                saveState();
                floodFill(x, y, targetColor, currentColor);
            } else {
                drawPixel(x, y);
            }
        }
        
        // Update grid size
        function updateGridSize() {
            gridWidth = parseInt(document.getElementById('gridWidth').value);
            gridHeight = parseInt(document.getElementById('gridHeight').value);
            pixelSize = Math.min(512 / gridWidth, 512 / gridHeight);
            initializeGrid();
        }
        
        // Clear canvas
        function clearCanvas() {
            saveState();
            for (let y = 0; y < gridHeight; y++) {
                for (let x = 0; x < gridWidth; x++) {
                    pixels[y][x].setAttribute('fill', 'transparent');
                }
            }
        }
        
        // Shift pixels functions
        function shiftPixels(direction) {
            saveState();
            
            // Create a copy of current pixel colors
            const colorMap = [];
            for (let y = 0; y < gridHeight; y++) {
                colorMap[y] = [];
                for (let x = 0; x < gridWidth; x++) {
                    colorMap[y][x] = pixels[y][x].getAttribute('fill');
                }
            }
            
            // Shift based on direction
            for (let y = 0; y < gridHeight; y++) {
                for (let x = 0; x < gridWidth; x++) {
                    let sourceX = x;
                    let sourceY = y;
                    
                    switch(direction) {
                        case 'up':
                            sourceY = (y + 1) % gridHeight;
                            break;
                        case 'down':
                            sourceY = (y - 1 + gridHeight) % gridHeight;
                            break;
                        case 'left':
                            sourceX = (x + 1) % gridWidth;
                            break;
                        case 'right':
                            sourceX = (x - 1 + gridWidth) % gridWidth;
                            break;
                    }
                    
                    pixels[y][x].setAttribute('fill', colorMap[sourceY][sourceX]);
                }
            }
            
            updatePreview();
        }
        
        // File upload handling
        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const parser = new DOMParser();
                const svgDoc = parser.parseFromString(e.target.result, 'image/svg+xml');
                const svgElement = svgDoc.querySelector('svg');
                
                if (!svgElement) {
                    alert('Invalid SVG file');
                    return;
                }
                
                parseSVGToPixels(svgElement);
            };
            reader.readAsText(file);
        }
        
        function parseSVGToPixels(svgElement) {
            // Get viewBox or width/height
            let width, height;
            const viewBox = svgElement.getAttribute('viewBox');
            if (viewBox) {
                const [x, y, w, h] = viewBox.split(' ').map(Number);
                width = w;
                height = h;
            } else {
                width = parseInt(svgElement.getAttribute('width')) || 24;
                height = parseInt(svgElement.getAttribute('height')) || 24;
            }
            
            // Update grid size if needed
            if (width !== gridWidth || height !== gridHeight) {
                document.getElementById('gridWidth').value = width;
                document.getElementById('gridHeight').value = height;
                updateGridSize();
            }
            
            // Clear current canvas
            clearCanvas();
            
            // Parse rect elements
            const rects = svgElement.querySelectorAll('rect');
            rects.forEach(rect => {
                const x = parseInt(rect.getAttribute('x'));
                const y = parseInt(rect.getAttribute('y'));
                const w = parseInt(rect.getAttribute('width'));
                const h = parseInt(rect.getAttribute('height'));
                const fill = rect.getAttribute('fill') || '#000000';
                
                // Fill the pixels
                for (let py = y; py < y + h && py < gridHeight; py++) {
                    for (let px = x; px < x + w && px < gridWidth; px++) {
                        if (px >= 0 && py >= 0 && px < gridWidth && py < gridHeight) {
                            pixels[py][px].setAttribute('fill', fill);
                        }
                    }
                }
            });
            
            // Parse path elements (simplified - just fill bounding box)
            const paths = svgElement.querySelectorAll('path');
            paths.forEach(path => {
                const bbox = path.getBBox ? path.getBBox() : {x: 0, y: 0, width: 0, height: 0};
                const fill = path.getAttribute('fill') || '#000000';
                if (fill !== 'none') {
                    const x = Math.floor(bbox.x);
                    const y = Math.floor(bbox.y);
                    const w = Math.ceil(bbox.width);
                    const h = Math.ceil(bbox.height);
                    
                    for (let py = y; py < y + h && py < gridHeight; py++) {
                        for (let px = x; px < x + w && px < gridWidth; px++) {
                            if (px >= 0 && py >= 0 && px < gridWidth && py < gridHeight) {
                                pixels[py][px].setAttribute('fill', fill);
                            }
                        }
                    }
                }
            });
        }
        
        // Download functions
        function downloadSVG() {
            // Create a clean SVG without strokes
            const cleanSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            cleanSvg.setAttribute('width', gridWidth);
            cleanSvg.setAttribute('height', gridHeight);
            cleanSvg.setAttribute('viewBox', `0 0 ${gridWidth} ${gridHeight}`);
            cleanSvg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
            
            // Copy pixels without stroke
            for (let y = 0; y < gridHeight; y++) {
                for (let x = 0; x < gridWidth; x++) {
                    const color = pixels[y][x].getAttribute('fill');
                    if (color !== 'transparent') {
                        const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        rect.setAttribute('x', x);
                        rect.setAttribute('y', y);
                        rect.setAttribute('width', 1);
                        rect.setAttribute('height', 1);
                        rect.setAttribute('fill', color);
                        cleanSvg.appendChild(rect);
                    }
                }
            }
            
            const svgData = new XMLSerializer().serializeToString(cleanSvg);
            const blob = new Blob([svgData], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = 'pixel-art.svg';
            link.click();
            URL.revokeObjectURL(url);
        }
        
        function downloadImage() {
            const svgData = new XMLSerializer().serializeToString(canvas);
            const svgBlob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
            const url = URL.createObjectURL(svgBlob);
            
            const img = new Image();
            img.onload = function() {
                const canvas2d = document.createElement('canvas');
                canvas2d.width = canvas.getAttribute('width');
                canvas2d.height = canvas.getAttribute('height');
                const ctx = canvas2d.getContext('2d');
                ctx.drawImage(img, 0, 0);
                
                canvas2d.toBlob(function(blob) {
                    const pngUrl = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = pngUrl;
                    link.download = 'pixel-art.png';
                    link.click();
                    URL.revokeObjectURL(pngUrl);
                });
                
                URL.revokeObjectURL(url);
            };
            img.src = url;
        }
        
        // Keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            // Cmd+Z or Ctrl+Z for undo
            if ((e.metaKey || e.ctrlKey) && e.key === 'z' && !e.shiftKey) {
                e.preventDefault();
                undo();
            }
            // Cmd+Shift+Z or Ctrl+Shift+Z for redo
            else if ((e.metaKey || e.ctrlKey) && e.key === 'z' && e.shiftKey) {
                e.preventDefault();
                redo();
            }
            // Cmd+Y or Ctrl+Y for redo (alternative)
            else if ((e.metaKey || e.ctrlKey) && e.key === 'y') {
                e.preventDefault();
                redo();
            }
            // C key for color picker mode
            else if (e.key === 'c' || e.key === 'C') {
                isColorPickerMode = true;
                canvas.style.cursor = 'crosshair';
            }
            // X key for transparent mode
            else if (e.key === 'x' || e.key === 'X') {
                isTransparentMode = true;
                canvas.style.cursor = 'crosshair';
            }
        });
        
        document.addEventListener('keyup', function(e) {
            // Release C key
            if (e.key === 'c' || e.key === 'C') {
                isColorPickerMode = false;
                canvas.style.cursor = 'crosshair';
            }
            // Release X key
            else if (e.key === 'x' || e.key === 'X') {
                isTransparentMode = false;
                canvas.style.cursor = 'crosshair';
            }
        });
        
        // Scale button handling
        document.querySelectorAll('.scale-button').forEach(button => {
            button.addEventListener('click', function() {
                document.querySelectorAll('.scale-button').forEach(b => b.classList.remove('active'));
                this.classList.add('active');
                previewScale = parseInt(this.dataset.scale);
                updatePreview();
            });
        });
        
        // Background handling
        function handleBackgroundUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                backgroundImage = e.target.result;
                updatePreview();
            };
            reader.readAsDataURL(file);
        }
        
        function clearBackground() {
            backgroundImage = null;
            updatePreview();
        }
        
        // Initialize
        initializeGrid();
    </script>
</body>
</html>