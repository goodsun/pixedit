<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixel Art Editor</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background-color: #f0f0f0;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .editor-container {
            display: flex;
            gap: 30px;
            margin-bottom: 20px;
        }
        
        .canvas-section {
            flex: 1;
        }
        
        .preview-section {
            width: 300px;
            background-color: #f8f8f8;
            padding: 20px;
            border-radius: 8px;
        }
        
        .preview-section h3 {
            margin-top: 0;
            margin-bottom: 15px;
            font-size: 16px;
            color: #333;
        }
        
        .preview-box {
            background-image: 
                linear-gradient(45deg, #ddd 25%, transparent 25%), 
                linear-gradient(-45deg, #ddd 25%, transparent 25%), 
                linear-gradient(45deg, transparent 75%, #ddd 75%), 
                linear-gradient(-45deg, transparent 75%, #ddd 75%);
            background-size: 10px 10px;
            background-position: 0 0, 0 5px, 5px -5px, -5px 0px;
            border: 1px solid #ccc;
            padding: 20px;
            text-align: center;
            margin-bottom: 20px;
            min-height: 100px;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }
        
        #previewCanvas {
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }
        
        .scale-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .scale-button {
            padding: 5px 10px;
            border: 1px solid #ccc;
            background-color: white;
            cursor: pointer;
            border-radius: 4px;
            font-size: 12px;
        }
        
        .scale-button:hover {
            background-color: #f0f0f0;
        }
        
        .scale-button.active {
            background-color: #4CAF50;
            color: white;
            border-color: #4CAF50;
        }
        
        h1 {
            text-align: center;
            color: #333;
        }
        
        .controls {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            align-items: center;
        }
        
        .color-picker {
            display: flex;
            gap: 5px;
            align-items: center;
        }
        
        .color-button {
            width: 30px;
            height: 30px;
            border: 2px solid #ccc;
            cursor: pointer;
            transition: transform 0.1s;
        }
        
        .color-button:hover {
            transform: scale(1.1);
        }
        
        .color-button.selected {
            border: 3px solid #333;
        }
        
        #customColor {
            width: 50px;
            height: 30px;
            cursor: pointer;
        }
        
        .tool-button {
            padding: 8px 15px;
            border: 1px solid #ccc;
            background-color: white;
            cursor: pointer;
            border-radius: 4px;
            transition: background-color 0.2s;
        }
        
        .tool-button:hover {
            background-color: #f0f0f0;
        }
        
        .tool-button.active {
            background-color: #4CAF50;
            color: white;
        }
        
        .bg-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .bg-button {
            padding: 5px 12px;
            border: 2px solid #ccc;
            background-color: #f0f0f0;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
            border-radius: 4px;
        }
        
        .bg-button:hover {
            background-color: #e0e0e0;
        }
        
        .bg-button.active {
            background-color: #4CAF50;
            color: white;
            border-color: #4CAF50;
        }
        
        #customBgColor {
            width: 50px;
            height: 30px;
            cursor: pointer;
        }
        
        #canvas-container {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
            position: relative;
            transition: all 0.3s ease;
        }
        
        #canvas-container.drag-over {
            transform: scale(1.02);
        }
        
        #canvas-container.drag-over::after {
            content: 'Drop image here';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(76, 175, 80, 0.9);
            color: white;
            padding: 20px 40px;
            border-radius: 8px;
            font-size: 18px;
            font-weight: bold;
            pointer-events: none;
            z-index: 10;
        }
        
        #pixelCanvas {
            border: 2px solid #333;
            cursor: crosshair;
            background-image: 
                linear-gradient(45deg, #ddd 25%, transparent 25%), 
                linear-gradient(-45deg, #ddd 25%, transparent 25%), 
                linear-gradient(45deg, transparent 75%, #ddd 75%), 
                linear-gradient(-45deg, transparent 75%, #ddd 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
        }
        
        #pixelCanvas.bg-white {
            background: white;
        }
        
        #pixelCanvas.bg-dark {
            background: #2a2a2a;
        }
        
        #pixelCanvas.bg-custom {
            background-image: none;
        }
        
        .action-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
        }
        
        button {
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.2s;
        }
        
        .btn-primary {
            background-color: #4CAF50;
            color: white;
        }
        
        .btn-primary:hover {
            background-color: #45a049;
        }
        
        .btn-secondary {
            background-color: #f44336;
            color: white;
        }
        
        .btn-secondary:hover {
            background-color: #da190b;
        }
        
        .btn-info {
            background-color: #2196F3;
            color: white;
        }
        
        .btn-info:hover {
            background-color: #0b7dda;
        }
        
        .grid-size {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .grid-preset-btn {
            padding: 5px 10px;
            border: 1px solid #ccc;
            background-color: white;
            cursor: pointer;
            border-radius: 4px;
            font-size: 12px;
            transition: all 0.2s;
        }
        
        .grid-preset-btn:hover {
            background-color: #f0f0f0;
        }
        
        .grid-preset-btn.active {
            background-color: #4CAF50;
            color: white;
            border-color: #4CAF50;
        }
        
        input[type="number"] {
            width: 60px;
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        
        .shift-controls {
            display: flex;
            gap: 5px;
            align-items: center;
        }
        .nav-header {
            background-color: #333;
            padding: 15px 0;
            margin: -20px -20px 20px -20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .nav-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .nav-title {
            color: white;
            font-size: 20px;
            font-weight: bold;
        }
        
        .nav-links {
            display: flex;
            gap: 20px;
        }
        
        .nav-link {
            color: white;
            text-decoration: none;
            padding: 8px 16px;
            border-radius: 4px;
            transition: background-color 0.2s;
        }
        
        .nav-link:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }
        
        .nav-link.active {
            background-color: #4CAF50;
        }
    </style>
</head>
<body>
    <nav class="nav-header">
        <div class="nav-container">
            <div class="nav-title">Pixel Art Tools</div>
            <div class="nav-links">
                <a href="index.html" class="nav-link active">Editor</a>
                <a href="composer.html" class="nav-link">Layer Composer</a>
            </div>
        </div>
    </nav>
    
    <div class="container">
        <h1>Pixel Art Editor</h1>
        
        <div class="controls">
            <div class="color-picker">
                <span>Color:</span>
                <div class="color-button selected" data-color="#000000" style="background-color: #000000"></div>
                <div class="color-button" data-color="#FF0000" style="background-color: #FF0000"></div>
                <div class="color-button" data-color="#00FF00" style="background-color: #00FF00"></div>
                <div class="color-button" data-color="#0000FF" style="background-color: #0000FF"></div>
                <div class="color-button" data-color="#FFFF00" style="background-color: #FFFF00"></div>
                <div class="color-button" data-color="#FF00FF" style="background-color: #FF00FF"></div>
                <div class="color-button" data-color="#00FFFF" style="background-color: #00FFFF"></div>
                <div class="color-button" data-color="#FFFFFF" style="background-color: #FFFFFF"></div>
                <div class="color-button" data-color="transparent" style="background-image: linear-gradient(45deg, #ccc 25%, transparent 25%), linear-gradient(-45deg, #ccc 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #ccc 75%), linear-gradient(-45deg, transparent 75%, #ccc 75%); background-size: 10px 10px; background-position: 0 0, 0 5px, 5px -5px, -5px 0px;"></div>
                <input type="color" id="customColor" value="#000000">
            </div>
            
            <div class="tools">
                <button class="tool-button active" data-tool="draw">Draw</button>
                <button class="tool-button" data-tool="erase">Erase</button>
                <button class="tool-button" data-tool="fill">Fill</button>
                <button class="tool-button" data-tool="select">Select</button>
            </div>
            
            <div class="grid-size">
                <span>Grid:</span>
                <button class="grid-preset-btn active" onclick="setGridSize(24)">24×24</button>
                <button class="grid-preset-btn" onclick="setGridSize(32)">32×32</button>
                <button class="grid-preset-btn" onclick="setGridSize(48)">48×48</button>
                <button class="grid-preset-btn" onclick="setGridSize(64)">64×64</button>
                <button class="grid-preset-btn" onclick="setGridSize(96)">96×96</button>
                <button class="tool-button" onclick="toggleGridVisibility()" title="Toggle Grid">⊞</button>
            </div>
            
            <div class="shift-controls">
                <button class="tool-button" onclick="shiftPixels('up')" title="Shift Up">↑</button>
                <button class="tool-button" onclick="shiftPixels('down')" title="Shift Down">↓</button>
                <button class="tool-button" onclick="shiftPixels('left')" title="Shift Left">←</button>
                <button class="tool-button" onclick="shiftPixels('right')" title="Shift Right">→</button>
                <button class="tool-button" onclick="rotateCanvas90()" title="Rotate 90°">↻</button>
            </div>
            
            <div class="bg-controls">
                <span>Background:</span>
                <button class="bg-button active" data-bg="checker" onclick="setCanvasBackground('checker')">Checker</button>
                <button class="bg-button" data-bg="white" onclick="setCanvasBackground('white')">Light</button>
                <button class="bg-button" data-bg="dark" onclick="setCanvasBackground('dark')">Dark</button>
                <input type="color" id="customBgColor" value="#808080" onchange="setCanvasBackground('custom')">
            </div>
        </div>
        
        <div class="editor-container">
            <div class="canvas-section">
                <div id="canvas-container">
                    <svg id="pixelCanvas" width="512" height="512" xmlns="http://www.w3.org/2000/svg">
                    </svg>
                </div>
            </div>
            
            <div class="preview-section">
                <h3>Real-time Preview</h3>
                <div class="scale-controls">
                    <span>Scale:</span>
                    <button class="scale-button active" data-scale="1">1x</button>
                    <button class="scale-button" data-scale="2">2x</button>
                    <button class="scale-button" data-scale="4">4x</button>
                    <button class="scale-button" data-scale="8">8x</button>
                    <button class="scale-button" data-scale="16">16x</button>
                </div>
                <div class="preview-box">
                    <svg id="previewCanvas" xmlns="http://www.w3.org/2000/svg"></svg>
                </div>
                <div style="text-align: center; color: #666; font-size: 12px;">
                    <span id="previewSize"></span>
                </div>
                <div style="margin-top: 15px;">
                    <input type="file" id="bgUpload" accept="image/*" style="display: none;" onchange="handleBackgroundUpload(event)">
                    <button class="tool-button" onclick="document.getElementById('bgUpload').click()" style="width: 100%;">Upload Background</button>
                    <button class="tool-button" onclick="clearBackground()" style="width: 100%; margin-top: 5px;">Clear Background</button>
                </div>
                <div style="margin-top: 10px;">
                    <input type="file" id="fgUpload" accept="image/*" style="display: none;" onchange="handleForegroundUpload(event)">
                    <button class="tool-button" onclick="document.getElementById('fgUpload').click()" style="width: 100%;">Upload Foreground</button>
                    <button class="tool-button" onclick="clearForeground()" style="width: 100%; margin-top: 5px;">Clear Foreground</button>
                </div>
            </div>
        </div>
        
        <div class="action-buttons">
            <button class="btn-info" onclick="undo()" title="Undo (Cmd+Z)">↶ Undo</button>
            <button class="btn-info" onclick="redo()" title="Redo (Cmd+Shift+Z)">↷ Redo</button>
            <input type="file" id="fileUpload" accept=".svg,image/*" style="display: none;" onchange="handleFileUpload(event)">
            <button class="btn-info" onclick="document.getElementById('fileUpload').click()">Upload Image</button>
            <button class="btn-primary" onclick="downloadSVG()">Download SVG</button>
            <button class="btn-info" onclick="showDownloadOptions()">SVG Options</button>
            <button class="btn-secondary" onclick="if(confirm('Clear the entire canvas?')) clearCanvas()">Clear</button>
        </div>
    </div>
    
    <!-- Download Options Modal -->
    <div id="downloadModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000;">
        <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 30px; border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); min-width: 300px;">
            <h3 style="margin-top: 0; margin-bottom: 20px;">Download SVG Options</h3>
            
            <div style="margin-bottom: 15px;">
                <input type="radio" id="fullCanvas" name="downloadType" value="full" checked>
                <label for="fullCanvas">Full Canvas (${gridWidth}×${gridHeight})</label>
            </div>
            
            <div style="margin-bottom: 15px;">
                <input type="radio" id="autoFit" name="downloadType" value="auto">
                <label for="autoFit">Auto-fit to content (trim blank space)</label>
            </div>
            
            <div style="margin-bottom: 20px;">
                <input type="radio" id="customArea" name="downloadType" value="custom">
                <label for="customArea">Custom area:</label>
                <div style="margin-left: 25px; margin-top: 10px;">
                    X: <input type="number" id="customX" value="0" min="0" max="${gridWidth}" style="width: 50px">
                    Y: <input type="number" id="customY" value="0" min="0" max="${gridHeight}" style="width: 50px">
                    <br style="margin-bottom: 5px">
                    Width: <input type="number" id="customW" value="${gridWidth}" min="1" max="${gridWidth}" style="width: 50px">
                    Height: <input type="number" id="customH" value="${gridHeight}" min="1" max="${gridHeight}" style="width: 50px">
                </div>
            </div>
            
            <div style="margin-bottom: 20px; padding-top: 15px; border-top: 1px solid #ddd;">
                <label style="font-weight: bold;">Display Size:</label>
                <div style="margin-top: 10px;">
                    <label style="display: block; margin-bottom: 5px;">
                        <input type="radio" name="displaySize" value="auto" checked> Auto (100% responsive)
                    </label>
                    <label style="display: block; margin-bottom: 5px;">
                        <input type="radio" name="displaySize" value="pixel"> Pixel size: 
                        <input type="number" id="pixelMultiplier" value="16" min="1" max="100" style="width: 50px">px per pixel
                    </label>
                    <label style="display: block;">
                        <input type="radio" name="displaySize" value="fixed"> Fixed size: 
                        <input type="number" id="fixedWidth" value="256" min="1" style="width: 60px">px
                    </label>
                </div>
            </div>
            
            <div style="display: flex; gap: 10px; justify-content: flex-end;">
                <button onclick="closeDownloadModal()" style="padding: 8px 16px;">Cancel</button>
                <button onclick="downloadWithOptions()" style="padding: 8px 16px; background: #4CAF50; color: white; border: none; border-radius: 4px;">Download</button>
            </div>
        </div>
    </div>

    <script>
        let currentColor = '#000000';
        let currentTool = 'draw';
        let isDrawing = false;
        let gridWidth = 24;
        let gridHeight = 24;
        let pixelSize = Math.min(512 / 24, 512 / 24);
        let pixels = [];
        let history = [];
        let historyStep = -1;
        const maxHistorySize = 50;
        let uploadedFileName = null; // Store the uploaded file name
        let previewScale = 1;
        let isColorPickerMode = false;
        let isTransparentMode = false;
        let backgroundImage = null;
        let foregroundImage = null;
        let isGridVisible = true; // Grid visibility state
        let selection = null; // Selection area: {startX, startY, endX, endY}
        let isSelecting = false;
        
        const canvas = document.getElementById('pixelCanvas');
        const previewCanvas = document.getElementById('previewCanvas');
        const previewSize = document.getElementById('previewSize');
        
        // History management
        function saveState() {
            const state = [];
            for (let y = 0; y < gridHeight; y++) {
                state[y] = [];
                for (let x = 0; x < gridWidth; x++) {
                    state[y][x] = pixels[y][x].getAttribute('fill');
                }
            }
            
            // Remove any states after current step
            history = history.slice(0, historyStep + 1);
            
            // Add new state
            history.push({
                state: state,
                width: gridWidth,
                height: gridHeight
            });
            
            // Limit history size
            if (history.length > maxHistorySize) {
                history.shift();
            } else {
                historyStep++;
            }
        }
        
        function undo() {
            if (historyStep > 0) {
                historyStep--;
                restoreState(history[historyStep]);
            }
        }
        
        function redo() {
            if (historyStep < history.length - 1) {
                historyStep++;
                restoreState(history[historyStep]);
            }
        }
        
        function restoreState(historyItem) {
            const { state, width, height } = historyItem;
            
            // Update grid size if needed
            if (width !== gridWidth || height !== gridHeight) {
                gridWidth = width;
                gridHeight = height;
                document.getElementById('gridWidth').value = width;
                document.getElementById('gridHeight').value = height;
                pixelSize = Math.min(512 / gridWidth, 512 / gridHeight);
                initializeGrid(false);
            }
            
            // Restore pixel colors
            for (let y = 0; y < gridHeight; y++) {
                for (let x = 0; x < gridWidth; x++) {
                    if (state[y] && state[y][x]) {
                        pixels[y][x].setAttribute('fill', state[y][x]);
                    }
                }
            }
            updatePreview();
        }
        
        // Initialize grid
        function initializeGrid(saveHistory = true) {
            canvas.innerHTML = '';
            pixels = [];
            
            const canvasWidth = gridWidth * pixelSize;
            const canvasHeight = gridHeight * pixelSize;
            
            canvas.setAttribute('width', canvasWidth);
            canvas.setAttribute('height', canvasHeight);
            
            // Don't create a background rect - let CSS handle the checkerboard pattern
            
            // Create grid
            for (let y = 0; y < gridHeight; y++) {
                pixels[y] = [];
                for (let x = 0; x < gridWidth; x++) {
                    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    rect.setAttribute('x', x * pixelSize);
                    rect.setAttribute('y', y * pixelSize);
                    rect.setAttribute('width', pixelSize);
                    rect.setAttribute('height', pixelSize);
                    rect.setAttribute('fill', 'transparent');
                    if (isGridVisible) {
                        rect.setAttribute('stroke', '#ddd');
                        rect.setAttribute('stroke-width', '1');
                    } else {
                        rect.setAttribute('stroke', 'none');
                        rect.setAttribute('stroke-width', '0');
                    }
                    rect.dataset.x = x;
                    rect.dataset.y = y;
                    
                    canvas.appendChild(rect);
                    pixels[y][x] = rect;
                }
            }
            
            // Create selection rectangle (initially hidden)
            const selectionRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            selectionRect.setAttribute('id', 'selectionRect');
            selectionRect.setAttribute('fill', 'none');
            selectionRect.setAttribute('stroke', '#4CAF50');
            selectionRect.setAttribute('stroke-width', '2');
            selectionRect.setAttribute('stroke-dasharray', '5,5');
            selectionRect.style.display = 'none';
            selectionRect.style.pointerEvents = 'none';
            canvas.appendChild(selectionRect);
            
            // Save initial state
            if (saveHistory) {
                saveState();
            }
            
            // Update preview
            updatePreview();
        }
        
        // Preview functions
        function updatePreview() {
            const actualWidth = gridWidth;
            const actualHeight = gridHeight;
            const scaledWidth = actualWidth * previewScale;
            const scaledHeight = actualHeight * previewScale;
            
            // Set style dimensions to maintain aspect ratio
            previewCanvas.style.width = scaledWidth + 'px';
            previewCanvas.style.height = scaledHeight + 'px';
            
            // Set the actual SVG dimensions to match the grid
            previewCanvas.setAttribute('width', actualWidth);
            previewCanvas.setAttribute('height', actualHeight);
            previewCanvas.setAttribute('viewBox', `0 0 ${actualWidth} ${actualHeight}`);
            
            // Clear preview
            previewCanvas.innerHTML = '';
            
            // Add background image if exists
            if (backgroundImage) {
                const image = document.createElementNS('http://www.w3.org/2000/svg', 'image');
                image.setAttribute('href', backgroundImage);
                image.setAttribute('x', '0');
                image.setAttribute('y', '0');
                image.setAttribute('width', actualWidth);
                image.setAttribute('height', actualHeight);
                image.setAttribute('preserveAspectRatio', 'xMidYMid slice');
                previewCanvas.appendChild(image);
            }
            
            // Copy pixels to preview
            for (let y = 0; y < gridHeight; y++) {
                for (let x = 0; x < gridWidth; x++) {
                    const color = pixels[y][x].getAttribute('fill');
                    if (color !== 'transparent') {
                        const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        rect.setAttribute('x', x);
                        rect.setAttribute('y', y);
                        rect.setAttribute('width', 1);
                        rect.setAttribute('height', 1);
                        rect.setAttribute('fill', color);
                        previewCanvas.appendChild(rect);
                    }
                }
            }
            
            // Add foreground image if exists
            if (foregroundImage) {
                const image = document.createElementNS('http://www.w3.org/2000/svg', 'image');
                image.setAttribute('href', foregroundImage);
                image.setAttribute('x', '0');
                image.setAttribute('y', '0');
                image.setAttribute('width', actualWidth);
                image.setAttribute('height', actualHeight);
                image.setAttribute('preserveAspectRatio', 'xMidYMid slice');
                previewCanvas.appendChild(image);
            }
            
            // Update size display
            previewSize.textContent = `${actualWidth} × ${actualHeight} pixels`;
        }
        
        // Color selection
        document.querySelectorAll('.color-button').forEach(button => {
            button.addEventListener('click', function() {
                document.querySelectorAll('.color-button').forEach(b => b.classList.remove('selected'));
                this.classList.add('selected');
                currentColor = this.dataset.color;
                document.getElementById('customColor').value = currentColor;
            });
        });
        
        document.getElementById('customColor').addEventListener('change', function() {
            currentColor = this.value;
            document.querySelectorAll('.color-button').forEach(b => b.classList.remove('selected'));
        });
        
        // Tool selection
        document.querySelectorAll('.tool-button').forEach(button => {
            button.addEventListener('click', function() {
                document.querySelectorAll('.tool-button').forEach(b => b.classList.remove('active'));
                this.classList.add('active');
                currentTool = this.dataset.tool;
                
                // Clear selection when switching tools
                if (currentTool !== 'select' && selection) {
                    clearSelection();
                }
            });
        });
        
        // Drawing functions
        function drawPixel(x, y) {
            if (x >= 0 && x < gridWidth && y >= 0 && y < gridHeight) {
                if (currentTool === 'draw') {
                    pixels[y][x].setAttribute('fill', currentColor);
                } else if (currentTool === 'erase') {
                    pixels[y][x].setAttribute('fill', 'transparent');
                }
                updatePreview();
            }
        }
        
        function floodFill(startX, startY, targetColor, fillColor) {
            if (targetColor === fillColor) return;
            
            const stack = [[startX, startY]];
            const visited = new Set();
            
            while (stack.length > 0) {
                const [x, y] = stack.pop();
                const key = `${x},${y}`;
                
                if (visited.has(key) || x < 0 || x >= gridWidth || y < 0 || y >= gridHeight) {
                    continue;
                }
                
                visited.add(key);
                
                if (pixels[y][x].getAttribute('fill') === targetColor) {
                    pixels[y][x].setAttribute('fill', fillColor);
                    
                    stack.push([x + 1, y]);
                    stack.push([x - 1, y]);
                    stack.push([x, y + 1]);
                    stack.push([x, y - 1]);
                }
            }
            updatePreview();
        }
        
        // Mouse events
        canvas.addEventListener('mousedown', function(e) {
            if (currentTool === 'select') {
                const rect = canvas.getBoundingClientRect();
                const x = Math.floor((e.clientX - rect.left) / pixelSize);
                const y = Math.floor((e.clientY - rect.top) / pixelSize);
                
                // Start new selection
                isSelecting = true;
                selection = {
                    startX: x,
                    startY: y,
                    endX: x,
                    endY: y
                };
                updateSelectionDisplay();
            } else {
                isDrawing = true;
                if (currentTool !== 'fill') {
                    saveState();
                }
                handleMouseAction(e);
            }
        });
        
        canvas.addEventListener('mousemove', function(e) {
            if (currentTool === 'select' && isSelecting) {
                const rect = canvas.getBoundingClientRect();
                const x = Math.floor((e.clientX - rect.left) / pixelSize);
                const y = Math.floor((e.clientY - rect.top) / pixelSize);
                
                // Update selection end point
                selection.endX = Math.max(0, Math.min(gridWidth - 1, x));
                selection.endY = Math.max(0, Math.min(gridHeight - 1, y));
                updateSelectionDisplay();
            } else if (isDrawing && currentTool !== 'fill') {
                handleMouseAction(e);
            }
        });
        
        canvas.addEventListener('mouseup', function() {
            isDrawing = false;
            isSelecting = false;
        });
        
        canvas.addEventListener('mouseleave', function() {
            isDrawing = false;
            isSelecting = false;
        });
        
        function handleMouseAction(e) {
            const rect = canvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) / pixelSize);
            const y = Math.floor((e.clientY - rect.top) / pixelSize);
            
            if (x < 0 || x >= gridWidth || y < 0 || y >= gridHeight) return;
            
            // Color picker mode (C key pressed)
            if (isColorPickerMode) {
                const pickedColor = pixels[y][x].getAttribute('fill');
                if (pickedColor !== 'transparent') {
                    currentColor = pickedColor;
                    document.getElementById('customColor').value = pickedColor;
                    // Update color button selection
                    document.querySelectorAll('.color-button').forEach(b => {
                        if (b.dataset.color === pickedColor) {
                            document.querySelectorAll('.color-button').forEach(btn => btn.classList.remove('selected'));
                            b.classList.add('selected');
                        } else {
                            b.classList.remove('selected');
                        }
                    });
                }
                return;
            }
            
            // Transparent mode (X key pressed)
            if (isTransparentMode) {
                if (!isDrawing) {
                    saveState();
                }
                pixels[y][x].setAttribute('fill', 'transparent');
                updatePreview();
                return;
            }
            
            if (currentTool === 'fill') {
                const targetColor = pixels[y][x].getAttribute('fill');
                saveState();
                floodFill(x, y, targetColor, currentColor);
            } else {
                drawPixel(x, y);
            }
        }
        
        // Set grid size with preset values
        function setGridSize(size) {
            // Update button states
            document.querySelectorAll('.grid-preset-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            // Update grid
            gridWidth = size;
            gridHeight = size;
            updateGridSize();
        }
        
        // Toggle grid visibility
        function toggleGridVisibility() {
            isGridVisible = !isGridVisible;
            
            // Update all pixel strokes
            for (let y = 0; y < gridHeight; y++) {
                for (let x = 0; x < gridWidth; x++) {
                    if (isGridVisible) {
                        pixels[y][x].setAttribute('stroke', '#ddd');
                        pixels[y][x].setAttribute('stroke-width', '1');
                    } else {
                        pixels[y][x].setAttribute('stroke', 'none');
                        pixels[y][x].setAttribute('stroke-width', '0');
                    }
                }
            }
        }
        
        // Update grid size
        function updateGridSize() {
            // Save current pixel data before updating
            const oldPixelData = [];
            const oldGridWidth = gridWidth;
            const oldGridHeight = gridHeight;
            
            for (let y = 0; y < oldGridHeight; y++) {
                oldPixelData[y] = [];
                for (let x = 0; x < oldGridWidth; x++) {
                    if (pixels[y] && pixels[y][x]) {
                        oldPixelData[y][x] = pixels[y][x].getAttribute('fill');
                    } else {
                        oldPixelData[y][x] = 'transparent';
                    }
                }
            }
            
            // Update grid dimensions - already set by setGridSize if called from there
            // If called directly, gridWidth and gridHeight should already be set
            pixelSize = Math.min(512 / gridWidth, 512 / gridHeight);
            
            // Initialize new grid without saving state
            initializeGrid(false);
            
            // Restore pixel data to the new grid
            const minWidth = Math.min(oldGridWidth, gridWidth);
            const minHeight = Math.min(oldGridHeight, gridHeight);
            
            for (let y = 0; y < minHeight; y++) {
                for (let x = 0; x < minWidth; x++) {
                    if (oldPixelData[y][x] !== 'transparent') {
                        pixels[y][x].setAttribute('fill', oldPixelData[y][x]);
                    }
                }
            }
            
            // Save state after transferring data
            saveState();
            updatePreview();
        }
        
        // Clear canvas
        function clearCanvas() {
            saveState();
            for (let y = 0; y < gridHeight; y++) {
                for (let x = 0; x < gridWidth; x++) {
                    pixels[y][x].setAttribute('fill', 'transparent');
                }
            }
        }
        
        // Shift pixels functions
        function shiftPixels(direction) {
            saveState();
            
            // Create a copy of current pixel colors
            const colorMap = [];
            for (let y = 0; y < gridHeight; y++) {
                colorMap[y] = [];
                for (let x = 0; x < gridWidth; x++) {
                    colorMap[y][x] = pixels[y][x].getAttribute('fill');
                }
            }
            
            // Shift based on direction
            for (let y = 0; y < gridHeight; y++) {
                for (let x = 0; x < gridWidth; x++) {
                    let sourceX = x;
                    let sourceY = y;
                    
                    switch(direction) {
                        case 'up':
                            sourceY = (y + 1) % gridHeight;
                            break;
                        case 'down':
                            sourceY = (y - 1 + gridHeight) % gridHeight;
                            break;
                        case 'left':
                            sourceX = (x + 1) % gridWidth;
                            break;
                        case 'right':
                            sourceX = (x - 1 + gridWidth) % gridWidth;
                            break;
                    }
                    
                    pixels[y][x].setAttribute('fill', colorMap[sourceY][sourceX]);
                }
            }
            
            updatePreview();
        }
        
        // Rotate canvas 90 degrees clockwise
        function rotateCanvas90() {
            saveState();
            
            // For non-square grids, we need to swap dimensions
            const oldGridWidth = gridWidth;
            const oldGridHeight = gridHeight;
            
            // Create a copy of current pixel colors
            const colorMap = [];
            for (let y = 0; y < oldGridHeight; y++) {
                colorMap[y] = [];
                for (let x = 0; x < oldGridWidth; x++) {
                    colorMap[y][x] = pixels[y][x].getAttribute('fill');
                }
            }
            
            // Update grid dimensions for non-square grids
            if (oldGridWidth !== oldGridHeight) {
                gridWidth = oldGridHeight;
                gridHeight = oldGridWidth;
                document.getElementById('gridWidth').value = gridWidth;
                document.getElementById('gridHeight').value = gridHeight;
                pixelSize = Math.min(512 / gridWidth, 512 / gridHeight);
                
                // Initialize new grid without saving state
                initializeGrid(false);
            }
            
            // Apply rotation: (x,y) -> (y, width-1-x)
            for (let y = 0; y < oldGridHeight; y++) {
                for (let x = 0; x < oldGridWidth; x++) {
                    const newX = y;
                    const newY = oldGridWidth - 1 - x;
                    if (newX < gridWidth && newY < gridHeight) {
                        pixels[newY][newX].setAttribute('fill', colorMap[y][x]);
                    }
                }
            }
            
            updatePreview();
        }
        
        // File upload handling
        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            // Save the filename without extension
            uploadedFileName = file.name.replace(/\.[^/.]+$/, '');
            
            if (file.type === 'image/svg+xml' || file.name.endsWith('.svg')) {
                // Handle SVG files
                const reader = new FileReader();
                reader.onload = function(e) {
                    const parser = new DOMParser();
                    const svgDoc = parser.parseFromString(e.target.result, 'image/svg+xml');
                    const svgElement = svgDoc.querySelector('svg');
                    
                    if (!svgElement) {
                        alert('Invalid SVG file');
                        return;
                    }
                    
                    parseSVGToPixels(svgElement);
                };
                reader.readAsText(file);
            } else if (file.type.startsWith('image/')) {
                // Handle raster images (JPG, PNG, etc.)
                const reader = new FileReader();
                reader.onload = function(e) {
                    const img = new Image();
                    img.onload = function() {
                        convertImageToPixels(img);
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            } else {
                alert('Please upload an image file (SVG, PNG, JPG, etc.)');
            }
        }
        
        function parseSVGToPixels(svgElement) {
            // Save state before overlaying
            saveState();
            
            // Get viewBox or width/height
            let width, height;
            const viewBox = svgElement.getAttribute('viewBox');
            if (viewBox) {
                const [x, y, w, h] = viewBox.split(' ').map(Number);
                width = w;
                height = h;
            } else {
                width = parseInt(svgElement.getAttribute('width')) || 24;
                height = parseInt(svgElement.getAttribute('height')) || 24;
            }
            
            // Don't update grid size - keep existing grid
            // Calculate scaling factors to fit SVG into current grid
            const scaleX = gridWidth / width;
            const scaleY = gridHeight / height;
            
            // Parse rect elements with scaling
            const rects = svgElement.querySelectorAll('rect');
            rects.forEach(rect => {
                const x = parseFloat(rect.getAttribute('x') || 0);
                const y = parseFloat(rect.getAttribute('y') || 0);
                const w = parseFloat(rect.getAttribute('width') || 0);
                const h = parseFloat(rect.getAttribute('height') || 0);
                const fill = rect.getAttribute('fill') || '#000000';
                
                // Skip transparent rects
                if (fill === 'transparent' || fill === 'none') return;
                
                // Scale coordinates to fit current grid
                const scaledX = Math.floor(x * scaleX);
                const scaledY = Math.floor(y * scaleY);
                const scaledW = Math.max(1, Math.ceil(w * scaleX));
                const scaledH = Math.max(1, Math.ceil(h * scaleY));
                
                // Overlay the pixels (don't replace transparent areas)
                for (let py = scaledY; py < scaledY + scaledH && py < gridHeight; py++) {
                    for (let px = scaledX; px < scaledX + scaledW && px < gridWidth; px++) {
                        if (px >= 0 && py >= 0 && px < gridWidth && py < gridHeight) {
                            pixels[py][px].setAttribute('fill', fill);
                        }
                    }
                }
            });
            
            // Parse path elements (simplified - just fill bounding box)
            const paths = svgElement.querySelectorAll('path');
            paths.forEach(path => {
                const fill = path.getAttribute('fill') || '#000000';
                
                // Skip transparent paths
                if (fill === 'none' || fill === 'transparent') return;
                
                // Try to get bounding box (may not work in all environments)
                try {
                    const bbox = path.getBBox();
                    const x = bbox.x;
                    const y = bbox.y;
                    const w = bbox.width;
                    const h = bbox.height;
                    
                    // Scale coordinates to fit current grid
                    const scaledX = Math.floor(x * scaleX);
                    const scaledY = Math.floor(y * scaleY);
                    const scaledW = Math.max(1, Math.ceil(w * scaleX));
                    const scaledH = Math.max(1, Math.ceil(h * scaleY));
                    
                    // Overlay the pixels
                    for (let py = scaledY; py < scaledY + scaledH && py < gridHeight; py++) {
                        for (let px = scaledX; px < scaledX + scaledW && px < gridWidth; px++) {
                            if (px >= 0 && py >= 0 && px < gridWidth && py < gridHeight) {
                                pixels[py][px].setAttribute('fill', fill);
                            }
                        }
                    }
                } catch (e) {
                    // getBBox might not work in some contexts, skip this path
                }
            });
        }
        
        // Download functions with optimization
        function downloadSVG() {
            // Default behavior: download full canvas with 16px per pixel
            const viewBox = { x: 0, y: 0, width: gridWidth, height: gridHeight };
            const displaySize = {
                type: 'pixel',
                width: gridWidth * 16,
                height: gridHeight * 16
            };
            downloadSVGWithViewBox(viewBox, displaySize);
        }
        
        // Legacy function kept for compatibility
        function downloadSVG_old() {
            // Create a clean SVG
            const cleanSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            cleanSvg.setAttribute('width', gridWidth);
            cleanSvg.setAttribute('height', gridHeight);
            cleanSvg.setAttribute('viewBox', `0 0 ${gridWidth} ${gridHeight}`);
            cleanSvg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
            cleanSvg.setAttribute('shape-rendering', 'crispEdges');
            
            // Group pixels by color for optimization
            const colorGroups = {};
            
            for (let y = 0; y < gridHeight; y++) {
                for (let x = 0; x < gridWidth; x++) {
                    const color = pixels[y][x].getAttribute('fill');
                    if (color !== 'transparent') {
                        if (!colorGroups[color]) {
                            colorGroups[color] = [];
                        }
                        colorGroups[color].push({x, y});
                    }
                }
            }
            
            // Create optimized rectangles by merging adjacent pixels
            for (const color in colorGroups) {
                const positions = colorGroups[color];
                const merged = mergeAdjacentPixels(positions);
                
                merged.forEach(rect => {
                    const r = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    r.setAttribute('x', rect.x);
                    r.setAttribute('y', rect.y);
                    r.setAttribute('width', rect.w);
                    r.setAttribute('height', rect.h);
                    r.setAttribute('fill', color);
                    cleanSvg.appendChild(r);
                });
            }
            
            // Serialize with minimal formatting
            let svgData = new XMLSerializer().serializeToString(cleanSvg);
            // Remove unnecessary whitespace
            svgData = svgData.replace(/>\s+</g, '><');
            // Convert hex colors to shorter format if possible
            svgData = svgData.replace(/#([0-9a-f])\1([0-9a-f])\2([0-9a-f])\3/gi, '#$1$2$3');
            
            const blob = new Blob([svgData], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = uploadedFileName ? `${uploadedFileName}.svg` : 'pixel-art.svg';
            link.click();
            URL.revokeObjectURL(url);
        }
        
        // Helper function to merge adjacent pixels into larger rectangles
        function mergeAdjacentPixels(positions) {
            const visited = new Set();
            const rectangles = [];
            
            positions.forEach(pos => {
                const key = `${pos.x},${pos.y}`;
                if (visited.has(key)) return;
                
                // Try to expand horizontally first
                let width = 1;
                let height = 1;
                
                // Check horizontal expansion
                while (positions.some(p => p.x === pos.x + width && p.y === pos.y) && 
                       !visited.has(`${pos.x + width},${pos.y}`)) {
                    width++;
                }
                
                // Check if we can expand vertically for the entire width
                let canExpandVertically = true;
                while (canExpandVertically) {
                    for (let w = 0; w < width; w++) {
                        if (!positions.some(p => p.x === pos.x + w && p.y === pos.y + height) ||
                            visited.has(`${pos.x + w},${pos.y + height}`)) {
                            canExpandVertically = false;
                            break;
                        }
                    }
                    if (canExpandVertically) {
                        height++;
                    }
                }
                
                // Mark all pixels in this rectangle as visited
                for (let h = 0; h < height; h++) {
                    for (let w = 0; w < width; w++) {
                        visited.add(`${pos.x + w},${pos.y + h}`);
                    }
                }
                
                rectangles.push({ x: pos.x, y: pos.y, w: width, h: height });
            });
            
            return rectangles;
        }
        
        function downloadImage() {
            const svgData = new XMLSerializer().serializeToString(canvas);
            const svgBlob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
            const url = URL.createObjectURL(svgBlob);
            
            const img = new Image();
            img.onload = function() {
                const canvas2d = document.createElement('canvas');
                canvas2d.width = canvas.getAttribute('width');
                canvas2d.height = canvas.getAttribute('height');
                const ctx = canvas2d.getContext('2d');
                ctx.drawImage(img, 0, 0);
                
                canvas2d.toBlob(function(blob) {
                    const pngUrl = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = pngUrl;
                    link.download = uploadedFileName ? `${uploadedFileName}.png` : 'pixel-art.png';
                    link.click();
                    URL.revokeObjectURL(pngUrl);
                });
                
                URL.revokeObjectURL(url);
            };
            img.src = url;
        }
        
        // Keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            // Cmd+Z or Ctrl+Z for undo
            if ((e.metaKey || e.ctrlKey) && e.key === 'z' && !e.shiftKey) {
                e.preventDefault();
                undo();
            }
            // Cmd+Shift+Z or Ctrl+Shift+Z for redo
            else if ((e.metaKey || e.ctrlKey) && e.key === 'z' && e.shiftKey) {
                e.preventDefault();
                redo();
            }
            // Cmd+Y or Ctrl+Y for redo (alternative)
            else if ((e.metaKey || e.ctrlKey) && e.key === 'y') {
                e.preventDefault();
                redo();
            }
            // Cmd+C or Ctrl+C for copy selection
            else if ((e.metaKey || e.ctrlKey) && e.key === 'c' && !e.shiftKey) {
                if (currentTool === 'select' && selection) {
                    e.preventDefault();
                    copySelectionToClipboard();
                }
            }
            // C key for color picker mode (only when not holding Cmd/Ctrl)
            else if ((e.key === 'c' || e.key === 'C') && !e.metaKey && !e.ctrlKey) {
                isColorPickerMode = true;
                canvas.style.cursor = 'crosshair';
            }
            // X key for transparent mode
            else if (e.key === 'x' || e.key === 'X') {
                isTransparentMode = true;
                canvas.style.cursor = 'crosshair';
            }
        });
        
        document.addEventListener('keyup', function(e) {
            // Release C key
            if (e.key === 'c' || e.key === 'C') {
                isColorPickerMode = false;
                canvas.style.cursor = 'crosshair';
            }
            // Release X key
            else if (e.key === 'x' || e.key === 'X') {
                isTransparentMode = false;
                canvas.style.cursor = 'crosshair';
            }
        });
        
        // Scale button handling
        document.querySelectorAll('.scale-button').forEach(button => {
            button.addEventListener('click', function() {
                document.querySelectorAll('.scale-button').forEach(b => b.classList.remove('active'));
                this.classList.add('active');
                previewScale = parseInt(this.dataset.scale);
                updatePreview();
            });
        });
        
        // Canvas background color handling
        function setCanvasBackground(type) {
            const canvas = document.getElementById('pixelCanvas');
            const buttons = document.querySelectorAll('.bg-button');
            
            // Remove all background classes
            canvas.classList.remove('bg-white', 'bg-dark', 'bg-custom');
            
            // Remove active class from all buttons
            buttons.forEach(btn => btn.classList.remove('active'));
            
            if (type === 'checker') {
                // Default checker pattern (no additional class needed)
                document.querySelector('[data-bg="checker"]').classList.add('active');
            } else if (type === 'white') {
                canvas.classList.add('bg-white');
                document.querySelector('[data-bg="white"]').classList.add('active');
            } else if (type === 'dark') {
                canvas.classList.add('bg-dark');
                document.querySelector('[data-bg="dark"]').classList.add('active');
            } else if (type === 'custom') {
                const customColor = document.getElementById('customBgColor').value;
                canvas.classList.add('bg-custom');
                canvas.style.backgroundColor = customColor;
                // No button to mark as active for custom color
            }
        }
        
        // Background handling
        function handleBackgroundUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                backgroundImage = e.target.result;
                updatePreview();
            };
            reader.readAsDataURL(file);
        }
        
        function clearBackground() {
            backgroundImage = null;
            updatePreview();
        }
        
        // Foreground handling
        function handleForegroundUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                foregroundImage = e.target.result;
                updatePreview();
            };
            reader.readAsDataURL(file);
        }
        
        function clearForeground() {
            foregroundImage = null;
            updatePreview();
        }
        
        // Drag & Drop handling
        function setupDragAndDrop() {
            const canvasContainer = document.getElementById('canvas-container');
            const body = document.body;
            
            // Prevent default drag behaviors
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                canvasContainer.addEventListener(eventName, preventDefaults, false);
                body.addEventListener(eventName, preventDefaults, false);
            });
            
            function preventDefaults(e) {
                e.preventDefault();
                e.stopPropagation();
            }
            
            // Highlight drop area when item is dragged over it
            ['dragenter', 'dragover'].forEach(eventName => {
                canvasContainer.addEventListener(eventName, highlight, false);
            });
            
            ['dragleave', 'drop'].forEach(eventName => {
                canvasContainer.addEventListener(eventName, unhighlight, false);
            });
            
            function highlight(e) {
                canvasContainer.classList.add('drag-over');
            }
            
            function unhighlight(e) {
                canvasContainer.classList.remove('drag-over');
            }
            
            // Handle dropped files
            canvasContainer.addEventListener('drop', handleDroppedFiles, false);
            
            function handleDroppedFiles(e) {
                const dt = e.dataTransfer;
                const files = dt.files;
                
                if (files.length > 0) {
                    handleDroppedFile(files[0]);
                }
            }
            
            function handleDroppedFile(file) {
                // Save the filename without extension
                uploadedFileName = file.name.replace(/\.[^/.]+$/, '');
                
                if (file.type === 'image/svg+xml' || file.name.endsWith('.svg')) {
                    // Handle SVG files
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        const parser = new DOMParser();
                        const svgDoc = parser.parseFromString(e.target.result, 'image/svg+xml');
                        const svgElement = svgDoc.querySelector('svg');
                        
                        if (svgElement) {
                            parseSVGToPixels(svgElement);
                        } else {
                            alert('Invalid SVG file');
                        }
                    };
                    reader.readAsText(file);
                } else if (file.type.startsWith('image/')) {
                    // Handle raster images (PNG, JPG, etc.)
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        const img = new Image();
                        img.onload = function() {
                            convertImageToPixels(img);
                        };
                        img.src = e.target.result;
                    };
                    reader.readAsDataURL(file);
                } else {
                    alert('Please drop an image file (SVG, PNG, JPG, etc.)');
                }
            }
        }
        
        // Convert raster image to pixels
        function convertImageToPixels(img) {
            saveState();
            
            // Create temporary canvas for image processing
            const tempCanvas = document.createElement('canvas');
            const ctx = tempCanvas.getContext('2d');
            
            // Scale image to fit grid
            tempCanvas.width = gridWidth;
            tempCanvas.height = gridHeight;
            ctx.drawImage(img, 0, 0, gridWidth, gridHeight);
            
            // Get pixel data
            const imageData = ctx.getImageData(0, 0, gridWidth, gridHeight);
            const data = imageData.data;
            
            // Convert to pixel art
            for (let y = 0; y < gridHeight; y++) {
                for (let x = 0; x < gridWidth; x++) {
                    const i = (y * gridWidth + x) * 4;
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    const a = data[i + 3];
                    
                    if (a > 128) { // Only set non-transparent pixels
                        const hex = '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
                        pixels[y][x].setAttribute('fill', hex);
                    }
                }
            }
            
            updatePreview();
        }
        
        // Modal functions
        function showDownloadOptions() {
            const modal = document.getElementById('downloadModal');
            // Update the label text with current grid size
            document.querySelector('label[for="fullCanvas"]').textContent = `Full Canvas (${gridWidth}×${gridHeight})`;
            // Update input max values
            document.getElementById('customX').max = gridWidth - 1;
            document.getElementById('customY').max = gridHeight - 1;
            document.getElementById('customW').max = gridWidth;
            document.getElementById('customW').value = gridWidth;
            document.getElementById('customH').max = gridHeight;
            document.getElementById('customH').value = gridHeight;
            modal.style.display = 'block';
        }
        
        function closeDownloadModal() {
            document.getElementById('downloadModal').style.display = 'none';
        }
        
        function getContentBounds() {
            let minX = gridWidth, minY = gridHeight, maxX = -1, maxY = -1;
            
            for (let y = 0; y < gridHeight; y++) {
                for (let x = 0; x < gridWidth; x++) {
                    const color = pixels[y][x].getAttribute('fill');
                    if (color !== 'transparent') {
                        minX = Math.min(minX, x);
                        minY = Math.min(minY, y);
                        maxX = Math.max(maxX, x);
                        maxY = Math.max(maxY, y);
                    }
                }
            }
            
            // If no content found, return full canvas
            if (maxX === -1) {
                return { x: 0, y: 0, width: gridWidth, height: gridHeight };
            }
            
            return {
                x: minX,
                y: minY,
                width: maxX - minX + 1,
                height: maxY - minY + 1
            };
        }
        
        function downloadWithOptions() {
            const downloadType = document.querySelector('input[name="downloadType"]:checked').value;
            let viewBox;
            
            if (downloadType === 'full') {
                viewBox = { x: 0, y: 0, width: gridWidth, height: gridHeight };
            } else if (downloadType === 'auto') {
                viewBox = getContentBounds();
            } else if (downloadType === 'custom') {
                viewBox = {
                    x: parseInt(document.getElementById('customX').value),
                    y: parseInt(document.getElementById('customY').value),
                    width: parseInt(document.getElementById('customW').value),
                    height: parseInt(document.getElementById('customH').value)
                };
            }
            
            const displaySizeType = document.querySelector('input[name="displaySize"]:checked').value;
            let displaySize = {};
            
            if (displaySizeType === 'auto') {
                displaySize = { type: 'auto' };
            } else if (displaySizeType === 'pixel') {
                const multiplier = parseInt(document.getElementById('pixelMultiplier').value);
                displaySize = { 
                    type: 'pixel', 
                    width: viewBox.width * multiplier,
                    height: viewBox.height * multiplier
                };
            } else if (displaySizeType === 'fixed') {
                const fixedWidth = parseInt(document.getElementById('fixedWidth').value);
                displaySize = { 
                    type: 'fixed', 
                    width: fixedWidth,
                    height: Math.round(fixedWidth * (viewBox.height / viewBox.width))
                };
            }
            
            closeDownloadModal();
            downloadSVGWithViewBox(viewBox, displaySize);
        }
        
        function downloadSVGWithViewBox(viewBox, displaySize = null) {
            // Create a clean SVG
            const cleanSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            
            // Set display size based on options
            if (displaySize && displaySize.type === 'pixel') {
                cleanSvg.setAttribute('width', displaySize.width);
                cleanSvg.setAttribute('height', displaySize.height);
            } else if (displaySize && displaySize.type === 'fixed') {
                cleanSvg.setAttribute('width', displaySize.width);
                cleanSvg.setAttribute('height', displaySize.height);
            } else {
                // Auto or default - use 100% for responsive sizing
                cleanSvg.setAttribute('width', '100%');
                cleanSvg.setAttribute('height', '100%');
            }
            
            cleanSvg.setAttribute('viewBox', `${viewBox.x} ${viewBox.y} ${viewBox.width} ${viewBox.height}`);
            cleanSvg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
            cleanSvg.setAttribute('shape-rendering', 'crispEdges');
            
            // Group pixels by color for optimization (only within viewBox)
            const colorGroups = {};
            
            for (let y = viewBox.y; y < viewBox.y + viewBox.height && y < gridHeight; y++) {
                for (let x = viewBox.x; x < viewBox.x + viewBox.width && x < gridWidth; x++) {
                    if (x >= 0 && y >= 0 && x < gridWidth && y < gridHeight) {
                        const color = pixels[y][x].getAttribute('fill');
                        if (color !== 'transparent') {
                            if (!colorGroups[color]) {
                                colorGroups[color] = [];
                            }
                            colorGroups[color].push({x, y});
                        }
                    }
                }
            }
            
            // Create optimized rectangles by merging adjacent pixels
            for (const color in colorGroups) {
                const positions = colorGroups[color];
                const merged = mergeAdjacentPixels(positions);
                
                merged.forEach(rect => {
                    const r = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    r.setAttribute('x', rect.x);
                    r.setAttribute('y', rect.y);
                    r.setAttribute('width', rect.w);
                    r.setAttribute('height', rect.h);
                    r.setAttribute('fill', color);
                    cleanSvg.appendChild(r);
                });
            }
            
            // Serialize with minimal formatting
            let svgData = new XMLSerializer().serializeToString(cleanSvg);
            // Remove unnecessary whitespace
            svgData = svgData.replace(/>\s+</g, '><');
            // Convert hex colors to shorter format if possible
            svgData = svgData.replace(/#([0-9a-f])\1([0-9a-f])\2([0-9a-f])\3/gi, '#$1$2$3');
            
            const blob = new Blob([svgData], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = uploadedFileName ? `${uploadedFileName}.svg` : 'pixel-art.svg';
            link.click();
            URL.revokeObjectURL(url);
        }
        
        // Selection functions
        function updateSelectionDisplay() {
            const selectionRect = document.getElementById('selectionRect');
            if (!selection || !selectionRect) return;
            
            const minX = Math.min(selection.startX, selection.endX);
            const minY = Math.min(selection.startY, selection.endY);
            const maxX = Math.max(selection.startX, selection.endX);
            const maxY = Math.max(selection.startY, selection.endY);
            
            selectionRect.setAttribute('x', minX * pixelSize);
            selectionRect.setAttribute('y', minY * pixelSize);
            selectionRect.setAttribute('width', (maxX - minX + 1) * pixelSize);
            selectionRect.setAttribute('height', (maxY - minY + 1) * pixelSize);
            selectionRect.style.display = 'block';
            
            // Create animated dash effect
            let dashOffset = 0;
            const animateDash = setInterval(() => {
                if (!selection || currentTool !== 'select') {
                    clearInterval(animateDash);
                    return;
                }
                dashOffset = (dashOffset + 1) % 10;
                selectionRect.setAttribute('stroke-dashoffset', dashOffset);
            }, 50);
        }
        
        function clearSelection() {
            selection = null;
            const selectionRect = document.getElementById('selectionRect');
            if (selectionRect) {
                selectionRect.style.display = 'none';
            }
        }
        
        function copySelectionToClipboard() {
            if (!selection) return;
            
            const minX = Math.min(selection.startX, selection.endX);
            const minY = Math.min(selection.startY, selection.endY);
            const maxX = Math.max(selection.startX, selection.endX);
            const maxY = Math.max(selection.startY, selection.endY);
            
            const width = maxX - minX + 1;
            const height = maxY - minY + 1;
            
            // Create SVG for the selection
            const selectionSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            selectionSvg.setAttribute('width', width);
            selectionSvg.setAttribute('height', height);
            selectionSvg.setAttribute('viewBox', `0 0 ${width} ${height}`);
            selectionSvg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
            selectionSvg.setAttribute('shape-rendering', 'crispEdges');
            
            // Copy pixels within selection
            for (let y = minY; y <= maxY; y++) {
                for (let x = minX; x <= maxX; x++) {
                    const color = pixels[y][x].getAttribute('fill');
                    if (color !== 'transparent') {
                        const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        rect.setAttribute('x', x - minX);
                        rect.setAttribute('y', y - minY);
                        rect.setAttribute('width', 1);
                        rect.setAttribute('height', 1);
                        rect.setAttribute('fill', color);
                        selectionSvg.appendChild(rect);
                    }
                }
            }
            
            // Convert to string
            const svgString = new XMLSerializer().serializeToString(selectionSvg);
            
            // Create blob for clipboard
            const svgBlob = new Blob([svgString], { type: 'image/svg+xml' });
            
            // Modern clipboard API
            if (navigator.clipboard && window.ClipboardItem) {
                const item = new ClipboardItem({
                    'image/svg+xml': svgBlob,
                    'text/plain': new Blob([svgString], { type: 'text/plain' })
                });
                
                navigator.clipboard.write([item]).then(() => {
                    // Show feedback
                    showCopyFeedback();
                }).catch(err => {
                    console.error('Failed to copy:', err);
                    // Fallback to text copy
                    fallbackTextCopy(svgString);
                });
            } else {
                // Fallback for older browsers
                fallbackTextCopy(svgString);
            }
        }
        
        function fallbackTextCopy(text) {
            const textarea = document.createElement('textarea');
            textarea.value = text;
            textarea.style.position = 'fixed';
            textarea.style.left = '-999999px';
            document.body.appendChild(textarea);
            textarea.select();
            try {
                document.execCommand('copy');
                showCopyFeedback();
            } catch (err) {
                console.error('Fallback copy failed:', err);
            }
            document.body.removeChild(textarea);
        }
        
        function showCopyFeedback() {
            // Visual feedback for copy action
            const feedback = document.createElement('div');
            feedback.textContent = 'Copied to clipboard!';
            feedback.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: #4CAF50;
                color: white;
                padding: 10px 20px;
                border-radius: 4px;
                font-size: 16px;
                z-index: 10000;
                pointer-events: none;
            `;
            document.body.appendChild(feedback);
            
            setTimeout(() => {
                feedback.style.opacity = '0';
                feedback.style.transition = 'opacity 0.5s';
                setTimeout(() => document.body.removeChild(feedback), 500);
            }, 1500);
        }
        
        // Initialize
        initializeGrid();
        setupDragAndDrop();
    </script>
</body>
</html>